package main

import (
	"errors"
	"strings"
	"unicode"
)

/*
=== Задача на распаковку ===

Создать Go функцию, осуществляющую примитивную распаковку строки, содержащую повторяющиеся символы / руны, например:
	- "a4bc2d5e" => "aaaabccddddde"
	- "abcd" => "abcd"
	- "45" => "" (некорректная строка)
	- "" => ""
Дополнительное задание: поддержка escape - последовательностей
	- qwe\4\5 => qwe45 (*)
	- qwe\45 => qwe44444 (*)
	- qwe\\5 => qwe\\\\\ (*)

В случае если была передана некорректная строка функция должна возвращать ошибку. Написать unit-тесты.

Функция должна проходить все тесты. Код должен проходить проверки go vet и golint.
*/

var ErrInvalidInput = errors.New("input string has invalid format")

func Unpack(s string) (string, error) {
	b := &strings.Builder{}

	/*
		Будем использовать три переменные для хранения состояния:
		- последнюю найденную букву
		- индикатор того, что до этого мы наткнулись на букву
		- индикатор того, что предыдущий символ - '\', и следующий символ мы должны обработать так же, как и букву
	*/
	var (
		lastLetter rune
		hasLetter  bool
		escape     bool
	)

	for _, r := range []rune(s) {
		// Включаем режим escape, если он до этого не был включен, а текущий символ - '\'
		if r == '\\' && !escape {
			escape = true
			continue
		}

		// Обрабатываем буквы, либо вообще любые символы в escape-режиме
		if unicode.IsLetter(r) || escape {
			// Поскольку, если мы зашли в это условие, то текущий символ - не указатель на количество повторений,
			// поэтому нужно ровно один раз добавить предыдущую "букву" в результат.
			if hasLetter {
				b.WriteRune(lastLetter)
			}

			// Запоминаем, что наткнулись на "букву"
			lastLetter = r
			hasLetter = true

			// Выключаем escape-режим, если он был включен, и переходим к следующему символу, игнорируя логику для
			// обработки цифр.
			if escape {
				escape = false
				continue
			}
		}

		// Обрабатываем цифры, которые указывают на количество повторений. Цифры в escape-режиме обрабатываются выше.
		if unicode.IsDigit(r) {
			// Если до этого не была найдена "буква", то возвращаем ошибку.
			if !hasLetter {
				return "", ErrInvalidInput
			}

			// Записываем последнюю букву в результат столько раз, сколько надо
			for i := 0; i < int(r-'0'); i++ {
				b.WriteRune(lastLetter)
			}

			// Считаем, что обработали текущую "букву"
			hasLetter = false
		}
	}

	// Если осталась какая-либо необработанная "буква", добавляем её в результат.
	if hasLetter {
		b.WriteRune(lastLetter)
	}

	return b.String(), nil
}
