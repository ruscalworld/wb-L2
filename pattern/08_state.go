package pattern

/*
	Реализовать паттерн «состояние».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/State_pattern

Паттерн подразумевает, что у объекта может быть одно из нескольких различных состояний. Состояние в данном случае
определяет поведение объекта при выполнении над ним каких-либо действий.

Преимущества - когда уместно, позволяет чётко определить, в каком из состояний находится некоторая сущность, что делает
код более понятным. Недостатки - вероятные затруднения при отслеживании переходов между состояниями во время
обслуживания кода.

Пример - конечные автоматы в гейм-дизайне. Объект, управляемый конечным автоматом, может находиться в одном из заданных
состояний, а переходы осуществляются при совершении определённых событий. При этом, в зависимости от состояния, объект
может осуществить только один из заданных для этого состояния переходов.
*/

// StatefulEntity олицетворяет некоторую сущность, имеющую состояние.
type StatefulEntity struct {
	CurrentState State
}

// PerformTransition осуществляет некоторый переход в зависимости от текущего состояния.
func (s *StatefulEntity) PerformTransition() {
	s.CurrentState.PerformTransition(s)
}

// State описывает общий вид состояние нашей сущности.
type State interface {
	PerformTransition(thing *StatefulEntity)
}

type FirstState struct{}

// PerformTransition осуществляет некоторый переход между состояниями.
// Для примера переводим сущность в состояние SecondState.
func (s *FirstState) PerformTransition(thing *StatefulEntity) {
	thing.CurrentState = &SecondState{}
}

type SecondState struct{}

// PerformTransition осуществляет некоторый переход между состояниями.
// Для примера переводим сущность в состояние FirstState.
func (s *SecondState) PerformTransition(thing *StatefulEntity) {
	thing.CurrentState = &FirstState{}
}
