package pattern

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern
*/

/*
Паттерн подразумевает создание некоторого метода, который будет создавать экземпляр некоторого общего типа в зависимости
от переданных в него параметров. При этом, конкретный тип, скрываемый за общим типом, может быть разным при разном
наборе входных данных.

Преимущества - возможность сокрытия процесса создания сложных структур. Недостатки - неочевидность того, какой именно
тип создал фабричный метод.

Пример - приложение, работающее с некоторой БД, при этом поддерживающее некоторое количество различных СУБД.
Пользователь указывает в конфиге, какую именно СУБД он хочет использовать, а также данные для подключения к серверу баз
данных. Структура конфига передаётся в фабричный метод, который в зависимости от указанных параметров возвращает
определённую структуру, позволяющую взаимодействовать с конкретной СУБД.
*/

// List - некоторый общий тип для списка.
type List interface {
	Add(a int)
	Get(i int) int
}

// CreateList - "фабричный метод", который будет создавать некоторый список в зависимости от переданных данных. В данном
// случае для примера возьмём такой критерий, как частота вставок в список.
func CreateList(frequentInserts bool) List {
	// Если необходимо часто добавлять новые элементы в список, то оптимальнее использовать связный список.
	if frequentInserts {
		return &LinkedList{}
	} else {
		return &ArrayList{}
	}
}

// ArrayList - список на базе обычного среза (и, как следствие, массива).
// За правильность реализации не ручаюсь, в данном примере она не играет большой роли.
type ArrayList struct {
	handle []int
}

func (l *ArrayList) Add(a int) {
	l.handle = append(l.handle, a)
}

func (l *ArrayList) Get(i int) int {
	return l.handle[i]
}

// LinkedList - связный список.
// За правильность реализации не ручаюсь, в данном примере она не играет большой роли.
type LinkedList struct {
	head *linkedListNode
}

func (l *LinkedList) Add(a int) {
	l.head = &linkedListNode{next: l.head, value: a}
}

func (l *LinkedList) Get(i int) int {
	for e := l.head; e != nil; e = e.next {
		if e.value == i {
			return e.value
		}
	}

	return -1
}

type linkedListNode struct {
	value int
	next  *linkedListNode
}
